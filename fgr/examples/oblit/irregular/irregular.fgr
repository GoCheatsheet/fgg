package main;
type HasFggType interface { getFggType() FggType };
type Any interface { HasFggType };
type Bool interface { HasFggType; Not() HasFggType };
type TT struct { };
func (x0 TT) getFggType() FggType { return TT[[]] };
type FF struct { };
func (x0 FF) getFggType() FggType { return FF[[]] };
func (this TT) Not() HasFggType { return FF{} };
func (this FF) Not() HasFggType { return TT{} };
type Nat interface { HasFggType; Add(n HasFggType) HasFggType };
type Zero struct { };
func (x0 Zero) getFggType() FggType { return Zero[[]] };
type Succ struct { pred Nat };
func (x0 Succ) getFggType() FggType { return Succ[[]] };
func (m Zero) Add(n HasFggType) HasFggType { return n.(Nat) };
func (m Succ) Add(n HasFggType) HasFggType { return Succ{m.pred.(Nat).Add(n.(Nat)).(Nat)} };
type Func interface { HasFggType; Apply(x HasFggType) HasFggType };
type incr struct { n Nat };
func (x0 incr) getFggType() FggType { return incr[[]] };
func (this incr) Apply(x HasFggType) HasFggType { return x.(Nat).Add(this.n.(Nat)).(Nat) };
type not struct { };
func (x0 not) getFggType() FggType { return not[[]] };
func (this not) Apply(x HasFggType) HasFggType { return x.(Bool).Not().(Bool) };
type Pair struct { a FggType; fst Any; snd Any };
func (x0 Pair) getFggType() FggType { return Pair[[x0.a]] };
type pairMap struct { a FggType; f Func };
func (x0 pairMap) getFggType() FggType { return pairMap[[x0.a]] };
func (p pairMap) Apply(x HasFggType) HasFggType { return Pair{p.a, p.f.(Func).Apply(x.(Pair).fst.(Any)).(Any), p.f.(Func).Apply(x.(Pair).snd.(Any)).(Any)} };
type Balanced interface { HasFggType; BalancedMap(f HasFggType) HasFggType };
type Leaf struct { a FggType };
func (x0 Leaf) getFggType() FggType { return Leaf[[x0.a]] };
type Node struct { a FggType; label Any; children Balanced };
func (x0 Node) getFggType() FggType { return Node[[x0.a]] };
func (leaf Leaf) BalancedMap(f HasFggType) HasFggType { return Leaf{leaf.a} };
func (node Node) BalancedMap(f HasFggType) HasFggType { return Node{node.a, f.(Func).Apply(node.label.(Any)).(Any), node.children.(Balanced).BalancedMap(pairMap{node.a, f.(Func)}).(Balanced)} };
type D struct { };
func (x0 D) getFggType() FggType { return D[[]] };
func (d D) _0() HasFggType { return Zero{} };
func (d D) _1() HasFggType { return Succ{D{}._0().(Nat)} };
func (d D) _2() HasFggType { return Succ{D{}._1().(Nat)} };
func (d D) _3() HasFggType { return Succ{D{}._2().(Nat)} };
func (d D) _4() HasFggType { return Succ{D{}._3().(Nat)} };
func (d D) _5() HasFggType { return Succ{D{}._4().(Nat)} };
func (d D) _6() HasFggType { return Succ{D{}._5().(Nat)} };
func (d D) _7() HasFggType { return Succ{D{}._6().(Nat)} };
func main() { _ = Node{Nat[[]], D{}._1().(Nat), Node{Pair[[Nat[[]]]], Pair{Nat[[]], D{}._2().(Nat), D{}._3().(Nat)}, Node{Pair[[Pair[[Nat[[]]]]]], Pair{Pair[[Nat[[]]]], Pair{Nat[[]], D{}._4().(Nat), D{}._5().(Nat)}, Pair{Nat[[]], D{}._6().(Nat), D{}._7().(Nat)}}, Leaf{Pair[[Pair[[Pair[[Nat[[]]]]]]]]}}}}.BalancedMap(incr{D{}._1().(Nat)}).(Balanced) }