package main;
type HasFggType interface { getFggType() FggType };
type Any interface { HasFggType };
type Bool interface { HasFggType; Not() HasFggType };
type TT struct { };
func (x0 TT) getFggType() FggType { return TT[[]] };
type FF struct { };
func (x0 FF) getFggType() FggType { return FF[[]] };
func (this TT) Not() HasFggType { return FF{} };
func (this FF) Not() HasFggType { return TT{} };
type Nat interface { HasFggType; Add(n HasFggType) HasFggType };
type Zero struct { };
func (x0 Zero) getFggType() FggType { return Zero[[]] };
type Succ struct { pred Nat };
func (x0 Succ) getFggType() FggType { return Succ[[]] };
func (m Zero) Add(n HasFggType) HasFggType { return n.(Nat) };
func (m Succ) Add(n HasFggType) HasFggType { return Succ{m.pred.(Nat).Add(n.(Nat)).(Nat)} };
type Func interface { HasFggType; Apply(x HasFggType) HasFggType };
type incr struct { n Nat };
func (x0 incr) getFggType() FggType { return incr[[]] };
func (this incr) Apply(x HasFggType) HasFggType { return x.(Nat).Add(this.n.(Nat)).(Nat) };
type not struct { };
func (x0 not) getFggType() FggType { return not[[]] };
func (this not) Apply(x HasFggType) HasFggType { return x.(Bool).Not().(Bool) };
type List interface { HasFggType; Map(b FggType, f HasFggType) HasFggType };
type Nil struct { a FggType };
func (x0 Nil) getFggType() FggType { return Nil[[x0.a]] };
type Cons struct { a FggType; head Any; tail List };
func (x0 Cons) getFggType() FggType { return Cons[[x0.a]] };
func (xs Nil) Map(b FggType, f HasFggType) HasFggType { return Nil{b} };
func (xs Cons) Map(b FggType, f HasFggType) HasFggType { return Cons{b, f.(Func).Apply(xs.head.(Any)).(Any), xs.tail.(List).Map(b, f.(Func)).(List)} };
type Pair struct { a FggType; b FggType; Fst Any; Snd Any };
func (x0 Pair) getFggType() FggType { return Pair[[x0.a, x0.b]] };
type D struct { };
func (x0 D) getFggType() FggType { return D[[]] };
func (d D) _1() HasFggType { return Succ{Zero{}} };
func (d D) _2() HasFggType { return Succ{D{}._1().(Nat)} };
func (d D) _3() HasFggType { return Succ{D{}._2().(Nat)} };
func main() { _ = Pair{List[[Bool[[]]]], List[[Nat[[]]]], Cons{Bool[[]], TT{}, Cons{Bool[[]], FF{}, Nil{Bool[[]]}}}.Map(Bool[[]], not{}).(List), Cons{Nat[[]], D{}._1().(Nat), Cons{Nat[[]], D{}._2().(Nat), Cons{Nat[[]], D{}._3().(Nat), Nil{Nat[[]]}}}}.Map(Nat[[]], incr{D{}._1().(Nat)}).(List)} }