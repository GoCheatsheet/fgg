package main;
type HasFggType interface { getFggType() FggType };
type Any interface { HasFggType };
type Eq interface { HasFggType; Equal(that HasFggType) HasFggType };
type Bool interface { HasFggType; Not() HasFggType; Equal(that HasFggType) HasFggType; Cond(a FggType, br HasFggType) HasFggType };
type Branches interface { HasFggType; IfTT() HasFggType; IfFF() HasFggType };
type TT struct { };
func (x0 TT) getFggType() FggType { return TT[[]] };
type FF struct { };
func (x0 FF) getFggType() FggType { return FF[[]] };
func (this TT) Not() HasFggType { return FF{} };
func (this FF) Not() HasFggType { return TT{} };
func (this TT) Equal(that HasFggType) HasFggType { return that.(Bool) };
func (this FF) Equal(that HasFggType) HasFggType { return that.(Bool).Not().(Bool) };
func (this TT) Cond(a FggType, br HasFggType) HasFggType { return br.(Branches).IfTT().(Any) };
func (this FF) Cond(a FggType, br HasFggType) HasFggType { return br.(Branches).IfFF().(Any) };
type exampleBr struct { x t; y t };
func (x0 exampleBr) getFggType() FggType { return exampleBr[[]] };
func (this exampleBr) IfTT() HasFggType { return this.x.m(this.y).(t) };
func (this exampleBr) IfFF() HasFggType { return this.x };
type t struct { };
func (x0 t) getFggType() FggType { return t[[]] };
func (x0 t) m(x1 HasFggType) HasFggType { return x1.(t) };
type Ex struct { };
func (x0 Ex) getFggType() FggType { return Ex[[]] };
func (d Ex) example(b HasFggType, x HasFggType, y HasFggType) HasFggType { return b.(Bool).Cond(t[[]], exampleBr{x.(t), y.(t)}).(t).m(t{}).(t) };
func main() { _ = Ex{}.example(TT{}, t{}, t{}).(t) }