package main;
type HasFggType interface { getFggType() FggType };
type Any interface { HasFggType };
type ToAny struct { any Any };
func (x0 ToAny) getFggType() FggType { return ToAny[[]] };
type Eq interface { HasFggType; Equal(that HasFggType) HasFggType };
type Bool interface { HasFggType; Not() HasFggType; Equal(that HasFggType) HasFggType; Cond(a FggType, br HasFggType) HasFggType };
type Branches interface { HasFggType; IfTT() HasFggType; IfFF() HasFggType };
type TT struct { };
func (x0 TT) getFggType() FggType { return TT[[]] };
type FF struct { };
func (x0 FF) getFggType() FggType { return FF[[]] };
func (this TT) Not() HasFggType { return FF{} };
func (this FF) Not() HasFggType { return TT{} };
func (this TT) Equal(that HasFggType) HasFggType { return that.(Bool) };
func (this FF) Equal(that HasFggType) HasFggType { return that.(Bool).Not().(Bool) };
func (this TT) Cond(a FggType, br HasFggType) HasFggType { return br.(Branches).IfTT().(Any) };
func (this FF) Cond(a FggType, br HasFggType) HasFggType { return br.(Branches).IfFF().(Any) };
type Func interface { HasFggType; Apply(x HasFggType) HasFggType };
type not struct { };
func (x0 not) getFggType() FggType { return not[[]] };
func (this not) Apply(x HasFggType) HasFggType { return x.(Bool).Not().(Bool) };
type compose struct { a FggType; b FggType; c FggType; f Func; g Func };
func (x0 compose) getFggType() FggType { return compose[[x0.a, x0.b, x0.c]] };
func (this compose) Apply(x HasFggType) HasFggType { return this.g.(Func).Apply(this.f.(Func).Apply(x.(Any)).(Any)).(Any) };
type List interface { HasFggType; Map(b FggType, f HasFggType) HasFggType; Member(x HasFggType) HasFggType };
type Nil struct { a FggType };
func (x0 Nil) getFggType() FggType { return Nil[[x0.a]] };
type Cons struct { a FggType; head Eq; tail List };
func (x0 Cons) getFggType() FggType { return Cons[[x0.a]] };
func (xs Nil) Map(b FggType, f HasFggType) HasFggType { return Nil{b} };
func (xs Cons) Map(b FggType, f HasFggType) HasFggType { return Cons{b, f.(Func).Apply(xs.head.(Eq)).(Eq), xs.tail.(List).Map(b, f.(Func)).(List)} };
type memberBr struct { b FggType; xs List; x Eq };
func (x0 memberBr) getFggType() FggType { return memberBr[[x0.b]] };
func (this memberBr) IfTT() HasFggType { return TT{} };
func (this memberBr) IfFF() HasFggType { return this.xs.(List).Member(this.x.(Eq)).(Bool) };
func (xs Nil) Member(x HasFggType) HasFggType { return FF{} };
func (xs Cons) Member(x HasFggType) HasFggType { return x.(Eq).Equal(xs.head.(Eq)).(Bool).Cond(Bool[[]], memberBr{xs.a, xs, x.(Eq)}).(Bool) };
func main() { _ = (if Cons{Bool[[]], TT{}, Cons{Bool[[]], FF{}, Nil{Bool[[]]}}}.Map(Bool[[]], not{}).(List).getFggType() << Cons[[Bool[[]]]] then Cons{Bool[[]], TT{}, Cons{Bool[[]], FF{}, Nil{Bool[[]]}}}.Map(Bool[[]], not{}).(List).(Cons) else panic).head.(Bool).Not().(Bool) }