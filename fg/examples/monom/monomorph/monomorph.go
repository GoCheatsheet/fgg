package main;
type Any interface {};
type Bool interface { Not() Bool };
type TT struct {};
type FF struct {};
func (this TT) Not() Bool { return FF{} };
func (this FF) Not() Bool { return TT{} };
type Nat interface { Add(n Nat) Nat };
type Zero struct {};
type Succ struct { pred Nat };
func (m Zero) Add(n Nat) Nat { return n };
func (m Succ) Add(n Nat) Nat { return Succ{m.pred.Add(n)} };
type FuncNatNat interface { Apply(x Nat) Nat };
type FuncBoolBool interface { Apply(x Bool) Bool };
type incr struct { n Nat };
func (this incr) Apply(x Nat) Nat { return x.Add(this.n) };
type not struct {};
func (this not) Apply(x Bool) Bool { return x.Not() };
type ListNat interface { MapNat(f FuncNatNat) ListNat };
type ListBool interface { MapBool(f FuncBoolBool) ListBool };
type NilBool struct {};
type NilNat struct {};
type ConsBool struct { head Bool; tail ListBool };
type ConsNat struct { head Nat; tail ListNat };
func (xs NilNat) MapNat(f FuncNatNat) ListNat { return NilNat{} };
func (xs NilBool) MapBool(f FuncBoolBool) ListBool { return NilBool{} };
func (xs ConsBool) MapBool(f FuncBoolBool) ListBool { return ConsBool{f.Apply(xs.head), xs.tail.MapBool(f)} };
func (xs ConsNat) MapNat(f FuncNatNat) ListNat { return ConsNat{f.Apply(xs.head), xs.tail.MapNat(f)} };
type PairListBoolListNat struct { Fst ListBool; Snd ListNat };
type D struct {};
func (d D) _1() Nat { return Succ{Zero{}} };
func (d D) _2() Nat { return Succ{D{}._1()} };
func (d D) _3() Nat { return Succ{D{}._2()} };
func main() { _ = PairListBoolListNat{ConsBool{TT{}, ConsBool{FF{}, NilBool{}}}.MapBool(not{}), ConsNat{D{}._1(), ConsNat{D{}._2(), ConsNat{D{}._3(), NilNat{}}}}.MapNat(incr{D{}._1()})} }