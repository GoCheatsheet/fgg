package main;
type Any interface {};
type EqBool interface { Equal(that Bool) Bool };
type Bool interface { Not() Bool; Equal(that Bool) Bool; CondBool(br BranchesBool) Bool };
type BranchesBool interface { IfTT() Bool; IfFF() Bool };
type TT struct {};
type FF struct {};
func (this TT) Not() Bool { return FF{} };
func (this FF) Not() Bool { return TT{} };
func (this TT) Equal(that Bool) Bool { return that };
func (this FF) Equal(that Bool) Bool { return that.Not() };
func (this TT) CondBool(br BranchesBool) Bool { return br.IfTT() };
func (this FF) CondBool(br BranchesBool) Bool { return br.IfFF() };
type FuncBoolBool interface { Apply(x Bool) Bool };
type not struct {};
func (this not) Apply(x Bool) Bool { return x.Not() };
type ListBool interface { MapBool(f FuncBoolBool) ListBool; Member(x Bool) Bool };
type NilBool struct {};
type ConsBool struct { head Bool; tail ListBool };
func (xs NilBool) MapBool(f FuncBoolBool) ListBool { return NilBool{} };
func (xs ConsBool) MapBool(f FuncBoolBool) ListBool { return ConsBool{f.Apply(xs.head), xs.tail.MapBool(f)} };
type memberBrBool struct { xs ListBool; x Bool };
func (this memberBrBool) IfTT() Bool { return TT{} };
func (this memberBrBool) IfFF() Bool { return this.xs.Member(this.x) };
func (xs NilBool) Member(x Bool) Bool { return FF{} };
func (xs ConsBool) Member(x Bool) Bool { return x.Equal(xs.head).CondBool(memberBrBool{xs, x}) };
func main() { _ = ConsBool{TT{}, ConsBool{FF{}, NilBool{}}}.MapBool(not{}).(ConsBool).head.Not() }