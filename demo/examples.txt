Reminder:
FG  = Featherweight Go
      A functional subset of Go with basic structs, methods, interfaces, duck
      typing and type asserts.
FGG = Featherweight Generic Go
      An extension of FG with parameterised struct/interface types and methods.
FGR = FG extended with "type reps" (a translation target for FGG)
      Type reps are values that represent FGG (parameterised) types.

We have a prototype implementation of FGG written in Go.  This implementation
(and parts of the underlying theory) are WIP, but it does demonstrate our main
ideas so far.  The prototype can:
(1) type check and evaluate FGG programs;
(2) compile FGG programs to FG programs via monomorphisation;
(3) compile FGG programs to FGR programs via a translation.

We have invited you to the FGG GitHub repo (currently private), which includes
all our examples (as linked below).  We have also attached a copy of the fgg
repo as a zip, and the examples can be found at the corresponding directories
there.

General notes:
So far, we have developed FGG as a minimal and simple framework to focus on
establishing formal definitions of the core concepts and correctness
properties (e.g., type safety).
We note that FGG includes parameterised methods.
Our next steps will be:
(i)  to build on this framework to consider more practical
     and efficient methods for its compilation; and
(ii) to consider extensions to "Middleweight" (Generic) Go, to include more
     features of Go.

About (2):
The current monomorphisation is intentionally very naive: it attempts to
statically analyse a source FGG program for all potentially required types,
and then "expands" the FGG type/method decls to FG types according all of
these possibilities.
We did not yet implement an actual "isMonormophisable" check -- for some FGG
programs (e.g., involving polymorphic recursion), the naive analysis will not
terminate (it will continuously encounter larger and larger types).
An initial solution would be to disallow FGG programs with polymorphic
recursion (a similar check to that in ML where it is disallowed to support
type inference).

- See here for FGG examples, including all those from our previous POPL
  submission:
  https://github.com/rhu1/fgg/tree/master/fgg/examples
  (fgg/examples in the zip)
- The above includes a non-monomorphisable example:
  https://github.com/rhu1/fgg/blob/master/fgg/examples/monom/box/box.fgg
- See here for the monomorphisation output (excluding the non-monomorphisable
  one):
  https://github.com/rhu1/fgg/tree/master/fg/examples/monom
  (fg/examples/monom in the zip)
  Note: all of these monom-generated FG programs are Go programs.
- See the further notes at the end for some words on each example.

About (3):
Again, our current translation method, called "obliteration", is intentionally
a very simple baseline method.
The idea is to compile FGG types into (non-parameterised) FGR type reps, which
record the base (FG) type name and reify FGG type arguments as special values.
The compilation into FGR also records the FGG method tables as additional meta
data.  The evaluation of FGR programs uses the type reps and meta data (e.g.,
in type asserts and interface-satisfaction checks) to simulate the source FGG
evaluation.
As the simplest method, obliteration translates (i.e., obliterates) all method
parameter and return types into something close to an "Any" (empty interface)
type, and restores correct typing and operation by inserting a lot of type
assertions (which exercise the type rep values and meta data as mentioned
above).
Building on this baseline, we can consider more efficient methods, e.g.,
eliminating unnecessary obliterations and asserts, and optimising the meta
data.
Unlike monomorphisation, obliteration works for all (well-typed) FGG programs.

- See here for the obliteration output of the same examples as above: 
  https://github.com/rhu1/fgg/tree/master/fgr/examples/oblit
  (fgr/examples/oblit in the zip)
  Note 1: The notation for type reps is currently: "type_name[[type_args]]".
          The FGR type of type reps themselves is "FggType" (for all type
          reps).
  Note 2: The above FGR code does not show the additional meta data (FGG
          method tables).
  Note 3: The FGR examples include the non-monomorphisable one:
  https://github.com/rhu1/fgg/blob/master/fgr/examples/oblit/box/box.fgr

In addition to the next steps already mentioned earlier, we are also
interested in how monomorphisation and translation methods could be combined.


---
Further notes on what is exercised in each example (these are found in
fgg/examples/popl20, with outputs in fg/examples/monom and
fgr/examples/oblit):

booleans.fgg
- additional method parameters and parameterised interfaces, but not both combined.

compose.fgg
- adds an interface parameterised by 2 types (Functions) and interfaces with both 
  additional method parameters and parameterisation (with constraints on the upper 
  bounds).

graph.fgg
- Parameterized interface with constraints but which are not used and so nothing 
is generated.

irregular.fgg
- Irregular types but monormophisation works due to instantiation not triggering 
  infinite expansions.

map.fgg
- Exercising additional method parameters via map and 3-way parameterized 
  types (function composition).
- Also features a type assert in the main expr, which gets translated by 
  obliteration to an FGR run-time type comparison using type reps (which we
  specifically encode using if-else conditionals).

box.fgg
- Cannot be monomorphised due to polymorphic recursion.
- Obliteration is fine, however.

box2.fgg
- Box example that works with monomorphisation (i.e., poly rec. is a “usage”
  issue, not a type definition issue).
- Note: although throwing naive monomorphisation goes through, it would be a
  different matter whether a static "isMonomorphisable" check (which we do not
  currently have) would allow this program.

ifacebox.fgg
- Boxes and maps over them, exercising parameterised interfaces and additional 
  method params.

